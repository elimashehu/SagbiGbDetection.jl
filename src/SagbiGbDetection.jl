module SagbiGbDetection
export wDeg, get_coeffs_exponents, initial_form, SagbiCriterion, change_ring, extractWeightVectors, weightVectorsRealizingSAGBI, Spair, division, reducedSpairs, BuchbergerCriterion

using Singular
using Oscar
function wDeg(monom, w::Vector{Int})
    dot(monom, w)
end

function get_coeffs_exponents(f)
    hcat(collect(Singular.coefficients(f)), collect(exponent_vectors(f)))
end

function initial_form(f, S, w)
    f_terms = get_coeffs_exponents(f)
    n, _ = size(f_terms)

    if n == 0
        return (f - f)
    end

    Q = MPolyBuildCtx(S)
    
    term0_coeff, term0_exponent = f_terms[1, 1], f_terms[1, 2]
    initial_form = push_term!(Q, term0_coeff, term0_exponent)
    
    d = wDeg(term0_exponent, w)
    
    for i in 2:n
        term_coeff, term_exponent = f_terms[i, 1], f_terms[i, 2]
        e = wDeg(term_exponent, w)
        
        if d < e
            finish(Q)
            Q = MPolyBuildCtx(S)
            initial_form = push_term!(Q, term_coeff, term_exponent)
            d = e
        elseif e == d
            initial_form = push_term!(Q, term_coeff, term_exponent)
        end
    end
    
    return initial_form 
end

function SagbiCriterion(G, R, w::Vector{Int})
    
    lt_G = Singular.leading_term.(G) 
    n = length(lt_G)
    
    A = Singular.leading_exponent_vector.(G)
    Aw = [wDeg(a, w) for a in A]
    S, vars = Singular.polynomial_ring(Singular.QQ, "z".*string.(1:n); ordering = ordering_wp(Aw))
    
    g = AlgebraHomomorphism(S, R, lt_G)
    h = AlgebraHomomorphism(S, R, G)

    IA = kernel(g)
    GrobnerI = gens(std(kernel(h)))
    
    inGrobnerI = [initial_form(f, S, Aw) for f in GrobnerI]
    
    if length(inGrobnerI) == 0
        return iszero(IA)
    end
    
    inI = Singular.Ideal(S, inGrobnerI)
    
    return equal(IA, inI)
end

function change_ring(G, R, w::Vector{Int})     
    
      gens = Singular.gens(R) 
      v = string.(gens)
      
      S, vars = Singular.polynomial_ring(Singular.QQ, v; ordering = ordering_wp(w)) 
    
      phi = Singular.AlgebraHomomorphism(R, S, Array(vars)) 
      new_G = phi.(G)
    
      return new_G, S
end

function extractWeightVectors(G)
    P = Oscar.newton_polytope(reduce(*, G))
    V = Oscar.vertices(P)
    
    normalCones = [Oscar.normal_cone(P, i) for i in 1:length(V)]
    
    n = length(V[1])
    id = Oscar.identity_matrix(Oscar.ZZ, n)     
    NonnegativeOrth = Oscar.positive_hull(-id)
    intersectedNormalCones = [Oscar.intersect(c,  NonnegativeOrth) for c in normalCones]
    
    goodCones = [c for c in intersectedNormalCones if dim(c) > 0]
    ray_s = [matrix(Oscar.ZZ, Oscar.rays(c)) for c in goodCones]
    ray_sum = [ones(Int, size(ray_s[i])[1])*ray_s[i] for i in 1:length(ray_s)] 
    
    return filter(w -> all(wi -> wi < 0, w), ray_sum)
end

"""
    weightVectorsRealizingSAGBI(G::Vector{spoly{n_Q}} and R <: Polynomial Ring over Q)

Returns an array of weight vectors, which may also be empty, for which the provided vector of polynomials 'G' constitutes a SAGBI basis. It also provides a true or false message indicating whether this is a SAGBI basis for all of the weight vectors generated by the method or not.

# Arguments
- `G::Vector{spoly{n_Q}} and R <: Polynomial Ring over Q: input generators.

# Examples
```julia-repl

julia> using SagbiGbDetection

julia> R, (l, x, y, z) = Singular.polynomial_ring(Singular.QQ, ["l","x","y","z"])
(Singular Polynomial Ring (QQ),(l,x,y,z),(dp(4),C), spoly{n_Q}[l, x, y, z])

julia> G = [z, z*x, z*y, z*x*(x^2+y^2),z*y*(x^2+y^2), l*z, l*z*x, l*z*y, l*z*x*(x^2+y^2), l*z*y*(x^2+y^2)]
10-element Vector{spoly{n_Q}}:
 z
 x*z
 y*z
 x^3*z + x*y^2*z
 x^2*y*z + y^3*z
 l*z
 l*x*z
 l*y*z
 l*x^3*z + l*x*y^2*z
 l*x^2*y*z + l*y^3*z

julia> weightVectorsRealizingSAGBI(G,R)
(Vector{ZZRingElem}[[1, 2, 1, 1], [1, 1, 2, 1]], true) 

```
"""
function weightVectorsRealizingSAGBI(G, R)
    weightVectors = extractWeightVectors(G)
    
    num_weight_vectors = length(weightVectors)
    
    filtered_weight_vectors = Vector{Bool}(undef, num_weight_vectors)
    for (i, w) in enumerate(weightVectors)
        newG, newR = change_ring(G, R, -Int.(w))
        filtered_weight_vectors[i] = SagbiCriterion(newG, newR, -Int.(w))
    end
    
    weight_vec_SAGBI = -weightVectors[filtered_weight_vectors]

    n = length(weight_vec_SAGBI)

    if n == 0
        return  weight_vec_SAGBI
    else
        return weight_vec_SAGBI, num_weight_vectors == n 
    end
end

function Spair(f, g) 
    lt_f = Singular.leading_term(f) 
    lt_g = Singular.leading_term(g)
    lcm_lt = Singular.lcm(lt_f, lt_g)
    return  Singular.divexact(lcm_lt, lt_f)*f - Singular.divexact(lcm_lt, lt_g)*g
end

function division(f, G, R) 
    m = length(G)
    quotients = Dict([(j, zero(f)) for j in 1:m])
    remainder = f

    while remainder != 0
        divided = false

        for i in 1:m
            if Singular.divrem(Singular.leading_term(remainder), Singular.leading_term(G[i]))[2] == 0
                q, _ = Singular.divrem(Singular.leading_term(remainder), Singular.leading_term(G[i]))
                quotients[i] += q
                remainder -= q * G[i]
                divided = true
                break
            end
        end

        if !divided
            break
        end
    end
    return remainder
end

function reducedSpairs(GS, R)   
    n = length(GS)
    return [division(Spair(GS[i], GS[j]), GS, R) for i in 1:n for j in (i+1):n]
end

function BuchbergerCriterion(GS,R)   
    all(reducedSpairs(GS, R)) do x
        x == Singular.zero(R)
    end
end


"""
weightVectorsRealizingGB(G::Vector{spoly{n_Q}}, R::Singular Polynomial Ring (QQ))

Provides a set of weight vectors, which may also be empty, for which the provided vector of polynomials 'G' serves as a Groebner basis. Additionally, it returns a Boolean value indicating whether this is a Groebner basis for all the weight vectors generated by the method or not.

# Arguments
- `G::Vector{spoly{n_Q}}`: input generators.
- `R::Singular Polynomial Ring (QQ)`: polynomial ring over Q.

# Examples
```julia-repl

julia> using SagbiGbDetection

julia> R, (x, y) = Singular.polynomial_ring(Singular.QQ, ["x","y"])
(Singular Polynomial Ring (QQ),(x,y),(dp(2),C), spoly{n_Q}[x, y])

julia> G = [y^2-x, x^2-1]
2-element Vector{spoly{n_Q}}:
 y^2 - x
 x^2 - 1

julia> weightVectorsRealizingGB(G, R)
(Vector{ZZRingElem}[[2, 2]], false)
```
"""
function weightVectorsRealizingGB(G, R) 
    weightVectors = extractWeightVectors(G)
    
    num_weight_vectors = length(weightVectors)
    
    filtered_weight_vectors = Vector{Bool}(undef, num_weight_vectors)
    
    for (i, w) in enumerate(weightVectors)
        newG, newR = change_ring(G, R, -Int.(w))
        filtered_weight_vectors[i] = BuchbergerCriterion(newG, newR)
    end

    weight_vec_GB = -weightVectors[filtered_weight_vectors]

    n = length(weight_vec_GB)

    if n == 0
        return  weight_vec_GB
    else
        return weight_vec_GB, num_weight_vectors == n 
    end
end

end # module SagbiGbDetection
